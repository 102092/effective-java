# 공유 중인 가변 데이터는 동기화 사용하라



## 질문

- 배타적 실행이란?
  - 어떤 스레드가 데이터를 변경하는 중이어서, 해당 객체를 다른 스레드가 보지 못하도록 하는 것
- 원자적atomic이란?
  - 여러 스레드가 같은 변수를 동기화 없이 수정하는 중이라도, 항상 어떤 스레드가 정상적으로 저장한 값을 온전히 읽어옴을 보장한다.
  - 즉 수정이 완전히 반영된 값을 얻어오는 건 보장하지만, 어떤 스레드가 저장한 값이 다른 스레드에게 보이는 점은 보장되지 않는다.

## 정리

- 동기화는 배타적 수행과, 스레드간 통신이라는 두가지 기능을 수행.
- violate 한정자는 가장 최근에 기록된 값을 읽게 됨을 보장.
- atomic long
- 가변 데이터는 단일 스레드에서만 쓰도록 하자.



### 자바 메모리 모델

![](https://t1.daumcdn.net/cfile/tistory/2759DB4356F40F6827)



- 스레드 스택 : 콜 스택이라고도 부르며, 쓰레드가 호출한 메소드의 현재 실행되는 코드를 보여주기 위한 정보들이 들어가 있음. (지역변수들..)
  - 모든 기본형 지역변수는 스레드 스택에 저장됨. 
  - 기본형 지역변수를 다른 스레드와 공유할 수는 없음.
- 힙 : JVM에서 생성한 모든 객체가 있음.
  - Byte, Integer..도 포함

![](https://t1.daumcdn.net/cfile/tistory/2737794856F415BA29)

- 객체가 가지고 있는 메소드, 그리고 이 메소드 내부에 있는 지역변수도, 스레드 스택에 저장된다.
- 객체의 멤버변수는 (기본형, 참조형 무관) 힙에 저장됨.
- 스태틱 클래스도 힙에 저장
- 이 힙에 저장된 것들은 모든 스레드에서 접근할 수 있음.
- 만약 두 스레드가 동시에 하나의 같은 객체 접근한다면, 각각 스레드 스택에 지역변수로 해당 객체의 복사본을 가지게 된다.



![](https://t1.daumcdn.net/cfile/tistory/2120924256F53DD115)

- 스레드 스택에 저장되는 것들은 지역변수 뿐



### 공유 객체의 가시성

![](https://t1.daumcdn.net/cfile/tistory/272DA53E56F5763F0B)

- volatile 키워드를 통해, 특정 변수에 대한 읽기 작업을 반드시 메인 메모리부터 수행하도록 하고, 쓰기 작업의 경우 항상 메모리 작업에 즉각 반영하도록 강제할 수 있는 것.
- Cache Memory가 있기 때문에 발생하는 문제



### 경합 조건

![](https://t1.daumcdn.net/cfile/tistory/2211BB3C56F57A7403)

- 어떤 공유 객체의 변수를 각각 스레드에서 가져와서 +1을 한다고 했을 때, 이 작업이 순차적으로 수행되었다면, obj.count는 초기 값에서 +2가 되어 저장될 것.
- 그렇지만 해당  작업이 동시에 수행되었다고 하면, 어떤 스레드가 적용될 것인지 상관없이 초기값에서 +1만 더한 값이 저장되어야할 것.
- synchronized 블록을 통해, 한 시점에 오직 하나의 스레드 만이 특정 코드 영역에 접근할 수 있도록 보장.
  - 그리고 volatile 키워드가 갖는 기능 처럼, 이 블록 안에서 접근하는 모든 변수들은 메인 메모리부터 읽어지고, 쓰기 작업도 메인 메모리에 바로 적용되도록 해줌.



### 참고

- https://parkcheolu.tistory.com/14
- [https://medium.com/@qwefgh90/jsr-133-java-memory-model-faq-%EB%B2%88%EC%97%AD-128487aebc1e](https://medium.com/@qwefgh90/jsr-133-java-memory-model-faq-번역-128487aebc1e)
